/**
 * Copyright (c) 2013, Bernhard Posselt <dev@bernhard-posselt.com>
 * This file is licensed under the Affero General Public License version 3 or
 * later.
 * See the COPYING file.
 */
angular.module('Notes', ['restangular', 'ngRoute'])
    .config(["$provide", "$routeProvider", "RestangularProvider", "$httpProvider", "$windowProvider", function ($provide, $routeProvider, RestangularProvider, $httpProvider, $windowProvider) {
    'use strict';
    // Always send the CSRF token by default
    $httpProvider.defaults.headers.common.requesttoken = oc_requesttoken;
    // you have to use $provide inside the config method to provide a globally
    // shared and injectable object
    $provide.value('Constants', {
        saveInterval: 5 * 1000 // miliseconds
    });
    // define your routes that that load templates into the ng-view
    $routeProvider.when('/notes/:noteId', {
        templateUrl: 'note.html',
        controller: 'NoteController as Note',
        resolve: {
            // $routeParams does not work inside resolve so use $route
            // note is the name of the argument that will be injected into the
            // controller
            /* @ngInject */
            note: ["$route", "$q", "is", "Restangular", function ($route, $q, is, Restangular) {
                var deferred = $q.defer();
                var noteId = $route.current.params.noteId;
                is.loading = true;
                Restangular.one('notes', noteId).get().then(function (note) {
                    is.loading = false;
                    deferred.resolve(note);
                }, function () {
                    is.loading = false;
                    deferred.reject();
                });
                return deferred.promise;
            }]
        }
    }).otherwise({
        redirectTo: '/'
    });
    // dynamically set base URL for HTTP requests, assume that there is no other
    // index.php in the routes
    var $window = $windowProvider.$get();
    var url = $window.location.href;
    var baseUrl = url.split('index.php')[0] + 'index.php/apps/notes';
    RestangularProvider.setBaseUrl(baseUrl);
}])
    .run(["$rootScope", "$location", "NotesModel", function ($rootScope, $location, NotesModel) {
    'use strict';
    // handle route errors
    $rootScope.$on('$routeChangeError', function () {
        var notes = NotesModel.getAll();
        // route change error should redirect to the latest note if possible
        if (notes.length > 0) {
            var sorted = notes.sort(function (a, b) {
                if (a.modified > b.modified) {
                    return 1;
                }
                else if (a.modified < b.modified) {
                    return -1;
                }
                else {
                    return 0;
                }
            });
            var note = notes[sorted.length - 1];
            $location.path('/notes/' + note.id);
        }
        else {
            $location.path('/');
        }
    });
}]);
/**
 * Copyright (c) 2013, Bernhard Posselt <dev@bernhard-posselt.com>
 * This file is licensed under the Affero General Public License version 3 or
 * later.
 * See the COPYING file.
 */
'use strict';
angular.module('Notes').controller('AppController', ["$location", "is", function ($location, is) {
    this.is = is;
    this.init = function (lastViewedNote) {
        if (lastViewedNote !== 0) {
            $location.path('/notes/' + lastViewedNote);
        }
    };
}]);
/**
 * Copyright (c) 2013, Bernhard Posselt <dev@bernhard-posselt.com>
 * This file is licensed under the Affero General Public License version 3 or
 * later.
 * See the COPYING file.
 */
angular.module('Notes').controller('NoteController', ["$routeParams", "NotesModel", "SaveQueue", "note", function ($routeParams, NotesModel, SaveQueue, note) {
    'use strict';
    var _this = this;
    NotesModel.updateIfExists(note);
    this.note = NotesModel.get($routeParams.noteId);
    this.isSaving = function () {
        return SaveQueue.isSaving();
    };
    this.updateTitle = function () {
        _this.note.title = _this.note.content.split('\n')[0] ||
            t('notes', 'New note');
    };
    this.save = function () {
        var note = _this.note;
        SaveQueue.add(note);
    };
}]);
/**
 * Copyright (c) 2013, Bernhard Posselt <dev@bernhard-posselt.com>
 * This file is licensed under the Affero General Public License version 3 or
 * later.
 * See the COPYING file.
 */
angular.module('Notes').controller('NotesController', ["$routeParams", "$location", "Restangular", "NotesModel", function ($routeParams, $location, Restangular, NotesModel) {
    'use strict';
    var _this = this;
    this.route = $routeParams;
    this.notes = NotesModel.getAll();
    var notesResource = Restangular.all('notes');
    // initial request for getting all notes
    notesResource.getList().then(function (notes) {
        NotesModel.addAll(notes);
    });
    this.create = function () {
        notesResource.post().then(function (note) {
            NotesModel.add(note);
            $location.path('/notes/' + note.id);
        });
    };
    this.delete = function (noteId) {
        var note = NotesModel.get(noteId);
        note.remove().then(function () {
            NotesModel.remove(noteId);
            _this.$emit('$routeChangeError');
        });
    };
}]);
/**
 * Copyright (c) 2013, Bernhard Posselt <dev@bernhard-posselt.com>
 * This file is licensed under the Affero General Public License version 3 or
 * later.
 * See the COPYING file.
 */
angular.module('Notes').directive('notesAutofocus', function () {
    'use strict';
    return {
        restrict: 'A',
        link: function (scope, element) {
            element.focus();
        }
    };
});
/**
 * Copyright (c) 2015, Hendrik Leppelsack
 * This file is licensed under the Affero General Public License version 3 or
 * later.
 * See the COPYING file.
 */
angular.module('Notes').directive('editor', ['$timeout', function ($timeout) {
        'use strict';
        return {
            restrict: 'A',
            scope: {
                editor: '=',
                beforeSave: '&'
            },
            link: function (scope, element) {
                var editor = mdEdit(element[0], { change: function (value) {
                        $timeout(function () {
                            scope.$apply(function () {
                                scope.editor.content = value;
                                scope.beforeSave();
                            });
                        });
                    } });
                editor.setValue(scope.editor.content);
            }
        };
    }]);
/**
 * Copyright (c) 2013, Bernhard Posselt <dev@bernhard-posselt.com>
 * This file is licensed under the Affero General Public License version 3 or
 * later.
 * See the COPYING file.
 */
angular.module('Notes').directive('notesIsSaving', ["$window", function ($window) {
    'use strict';
    return {
        restrict: 'A',
        scope: {
            'notesIsSaving': '='
        },
        link: function (scope) {
            $window.onbeforeunload = function () {
                if (scope.notesIsSaving) {
                    return t('notes', 'Note is currently saving. Leaving ' +
                        'the page will delete all changes!');
                }
                else {
                    return null;
                }
            };
        }
    };
}]);
/**
 * Copyright (c) 2013, Bernhard Posselt <dev@bernhard-posselt.com>
 * This file is licensed under the Affero General Public License version 3 or
 * later.
 * See the COPYING file.
 */
angular.module('Notes').directive('notesTimeoutChange', ["$timeout", function ($timeout) {
    'use strict';
    return {
        restrict: 'A',
        link: function (scope, element, attributes) {
            var interval = 300; // 300 miliseconds timeout after typing
            var timeout;
            element.on('input propertychange', function () {
                $timeout.cancel(timeout);
                timeout = $timeout(function () {
                    scope.$apply(attributes.notesTimeoutChange);
                }, interval);
            });
        }
    };
}]);
/**
 * Copyright (c) 2013, Bernhard Posselt <dev@bernhard-posselt.com>
 * This file is licensed under the Affero General Public License version 3 or
 * later.
 * See the COPYING file.
 */
angular.module('Notes').directive('notesTooltip', function () {
    'use strict';
    return {
        restrict: 'A',
        link: function (scope, element) {
            element.tooltip();
        }
    };
});
/**
 * Copyright (c) 2015, Hendrik Leppelsack
 * This file is licensed under the Affero General Public License version 3 or
 * later.
 * See the COPYING file.
 */
angular.module('Notes').filter('noteTitle', function () {
    'use strict';
    return function (value) {
        value = value.split('\n')[0] || 'newNote';
        return value.trim().replace(/^#+/g, '');
    };
});
/**
 * Copyright (c) 2013, Bernhard Posselt <dev@bernhard-posselt.com>
 * This file is licensed under the Affero General Public License version 3 or
 * later.
 * See the COPYING file.
 */
'use strict';
angular.module('Notes').factory('is', function () {
    return {
        loading: false
    };
});
/**
 * Copyright (c) 2013, Bernhard Posselt <dev@bernhard-posselt.com>
 * This file is licensed under the Affero General Public License version 3 or
 * later.
 * See the COPYING file.
 */
angular.module('Notes').factory('NotesModel', function () {
    'use strict';
    var NotesModel = function () {
        this.notes = [];
        this.notesIds = {};
    };
    NotesModel.prototype = {
        addAll: function (notes) {
            for (var i = 0; i < notes.length; i += 1) {
                this.add(notes[i]);
            }
        },
        add: function (note) {
            this.updateIfExists(note);
        },
        getAll: function () {
            return this.notes;
        },
        get: function (id) {
            return this.notesIds[id];
        },
        updateIfExists: function (updated) {
            var note = this.notesIds[updated.id];
            if (angular.isDefined(note)) {
                note.title = updated.title;
                note.modified = updated.modified;
                note.content = updated.content;
            }
            else {
                this.notes.push(updated);
                this.notesIds[updated.id] = updated;
            }
        },
        remove: function (id) {
            for (var i = 0; i < this.notes.length; i += 1) {
                var note = this.notes[i];
                if (note.id === id) {
                    this.notes.splice(i, 1);
                    delete this.notesIds[id];
                    break;
                }
            }
        }
    };
    return new NotesModel();
});
/**
 * Copyright (c) 2013, Bernhard Posselt <dev@bernhard-posselt.com>
 * This file is licensed under the Affero General Public License version 3 or
 * later.
 * See the COPYING file.
 */
angular.module('Notes').factory('SaveQueue', ["$q", function ($q) {
    'use strict';
    var SaveQueue = function () {
        this._queue = {};
        this._flushLock = false;
    };
    SaveQueue.prototype = {
        add: function (note) {
            this._queue[note.id] = note;
            this._flush();
        },
        _flush: function () {
            // if there are no changes dont execute the requests
            var keys = Object.keys(this._queue);
            if (keys.length === 0 || this._flushLock) {
                return;
            }
            else {
                this._flushLock = true;
            }
            var self = this;
            var requests = [];
            // iterate over updated objects and run an update request for
            // each one of them
            for (var i = 0; i < keys.length; i += 1) {
                var note = this._queue[keys[i]];
                // if the update finished, update the modified and title
                // attributes on the note
                requests.push(note.put().then(this._noteUpdateRequest.bind(null, note)));
            }
            this._queue = {};
            // if all update requests are completed, run the flush
            // again to update the next batch of queued notes
            $q.all(requests).then(function () {
                self._flushLock = false;
                self._flush();
            });
        },
        _noteUpdateRequest: function (note, response) {
            note.title = response.title;
            note.modified = response.modified;
        },
        isSaving: function () {
            return this._flushLock;
        }
    };
    return new SaveQueue();
}]);

//# sourceMappingURL=app.min.js.map